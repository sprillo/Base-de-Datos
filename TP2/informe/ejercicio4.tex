\section{Ejercicio 4}

Las bases de datos NoSQL del tipo \textit{column family} almacenan la informaci'on, no por filas como las bases de datos SQL tradicionales, sino por columnas. Esto permite realizar queries que requieren acceder a grandes cantidades de datos eficientemente. Esta eficiencia se basa en dos hip'otesis. La primera es que, en general, las consultas s'olo requieren un subconjuntos de la totalidad de las columnas de una tabla, con lo cual resulta conveniente poder restrigirse s'olo a las columnas necesarias. La segunda es que, cuando la cantidad de datos de la respuesta es grande, tendremos que leer casi todos los valores de una columna, por lo que resulta 'util que est'en almacenados consecutivamente.

Una base de datos de este tipo se compone de \textit{familias de columnas}. Cada familia de columnas se compone de varias \textit{claves de fila} (simbolizadas con K), y asociada a cada una de estas claves hay \textit{columnas} (simbolizadas con C) con sus respectivos valores. Finalmente, asociado a cada clave de fila tambi'en suele almacenarse un timestamp, que es utilizado para determinar el tiempo de expiraci'on de los datos.

Para dise\~nar bases de datos de este tipo, creamos, para cada query, una o m'as familias de columnas que sean capaces de responder a la consulta. Esto implica que los datos almacenados son estrictamente los requeridos para responder a las consultas.

\subsection{Consultas}

\subsubsection{Los empleados que atendieron clientes mayores de edad}

\begin{center}
\begin{tabular}{|c|c|}
\hline
\texttt{idRow} & K\\
\hline
\texttt{legajo\_empleado\_que\_atendio\_mayor} & C $\uparrow$\\
\hline
\end{tabular}
\end{center}

En este caso, tenemos una clave de fila \textit{dummy}, \texttt{idRow}, en la cual se almacenar'an una secuencia de columnas \texttt{legajo\_empleado\_que\_atendio\_mayor}. Cada valor de una columna \texttt{legajo\_empleado\_que\_atendio\_mayor} es el identificador de un empleado que atendi'o a una persona mayor de edad.

La actualizaci'on de esta familia es sencilla. Cada vez que se realiza una venta, debemos verificar si el cliente es mayor de edad, en cuyo caso insertamos en la familia al empleado que lo atendi'o, siempre que no estuviera en la familia de antemano.

\subsubsection{Los art'iculos m'as vendidos}

\begin{center}
\begin{tabular}{|c|c|}
\hline
\texttt{codigo\_articulo} & K\\
\hline
\texttt{cantidad\_vendida} & ++\\
\hline
\end{tabular}
\end{center}

A cada art'iculo le asociamos un contador \texttt{cantidad\_vendida}. Con esta informaci'on es f'acil extraer aquellos art'iculos cuyo valor del contador sea m'aximo.

La actualizaci'on consiste en incrementar el contador de un art'iculo, cada vez que es vendido.

\subsubsection{Los sectores donde trabajan exactamente 3 empleados}

\begin{center}
\begin{tabular}{|c|c|}
\hline
\texttt{codigo\_sector} & K\\
\hline
\texttt{legajo\_empleado\_del\_sector} & C $\uparrow$\\
\hline
\end{tabular}
\end{center}

Para cada sector, almacenamos todos los empleados que trabajan all'i. Determinar aquellos sectores donde trabajan exactamente 3 empleados consiste en determinar cu'ales tienen exactamente 3 columnas.

\subsubsection{El empleado que trabaja en m'as sectores}

Aqui podemos saber para un empledo todos los sectores donde trabaj'o, 
asi que tambi'en sabemos la cantidad.

\begin{center}
\begin{tabular}{|c|c|}
\hline
\texttt{legajo\_empleado} & K\\
\hline
\texttt{codigo\_sector\_donde\_trabaja} & C $\uparrow$\\
\hline
\end{tabular}
\end{center}

La desventaja de esta implementaci'on
es que debemos revisar todos los empleados de la base de datos. En la
siguiente alternativa tratamos de solucionar eso agregando una tabla.

\begin{center}
\begin{tabular}{|c|c|}
\hline
\texttt{row\_id} & K\\
\hline
\texttt{cantidad\_sectores\_trabaja} & C $\uparrow$\\
\hline
\texttt{empleados} & \\
\hline
\end{tabular}
\end{center}

Entonces al agregar para un empleado un nuevo sector donde trabajo, 
primero nos fijamos si en la primera tabla aparece dicho sector, si es asi
no actualizamos nada. Sino, sea $e$ el id el numero de legajo del empleado
y sea $s$ el nuevo sector y $n$ la cantidad de anterior donde trabajaba.
Tengo que remover a $e$ de aquellos que trabajaban en $n$ seccionesy agregarlo en
$n+1$. Adem'as, hay que actualizar la primera tabla.\\

Mateniendo esta relaci'on solo tenemos que ver la primera columna de 
$cantidad\_sectores\_trabaja$ y tomar alg'un empleado.


\subsubsection{Ranking de los clientes con mayor cantidad de compras}

Este es realmente muy similar al caso anterior. Podr'iamos decir, tal vez, 
que puede haber muchas cantidades de compras por usuario, pero esto no deber'ia
ser un problema. Proponemos:

\begin{center}
\begin{tabular}{|c|c|}
\hline
\texttt{dni\_usuario} & K\\
\hline
\texttt{ids\_compras\_realizadas} & C $\uparrow$\\
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|c|c|}
\hline
\texttt{row\_id} & K\\
\hline
\texttt{cantidad\_compras\_realizadas} & C $\uparrow$\\
\hline
\texttt{empleados} & \\
\hline
\end{tabular}
\end{center}

Notar que en las primeras columnas tenemos, justamente, los clientes que 
mas compraron.


En cambio, si no nos interesa cuales fueron exactamente las compras y podemos recorrer
toda la base de datos, las siguiente alternativa resulta razonable:

\begin{center}
\begin{tabular}{|c|c|}
\hline
\texttt{dni\_cliente} & K\\
\hline
\texttt{cantidad\_compras} & ++\\
\hline
\end{tabular}
\end{center}

Es decir, un contador de cantidad de compras por cliente.

\subsubsection{Cantidad de compras realizadas por clientes de misma edad}

Asumiendo que no necesitamos los clientes, sino solo la cantidad, podemos
tener la siguiente implementaci'on que es basicamente un contador por 
edad posible de cliente.

\begin{center}
\begin{tabular}{|c|c|}
\hline
\texttt{edad\_cliente} & K\\
\hline
\texttt{cantidad\_compras} & ++\\
\hline
\end{tabular}
\end{center}

\subsection{Sharding}
